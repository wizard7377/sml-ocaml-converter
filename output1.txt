module I = IntSyn let rec cidFromHead arg0 = match arg0 with | Const c -> c | Def c -> c let (indexArray : IntSyn.Head Queue.queue Array.array) = Array.array ((Global.maxCid + 1), Queue.empty) let rec reset () = Array.modify (function | _ -> Queue.empty) indexArray let rec update (a, c) = Array.update (indexArray, a, (Queue.insert (c, (Array.sub (indexArray, a))))) let rec install fromCS (Const c as h) = match (fromCS, (I.sgnLookup c)) with | (_, ConDec (_, _, _, _, A, I.Type)) -> update ((cidFromHead (I.targetHead A)), h) | (I.Clause, ConDef (_, _, _, _, A, I.Type, _)) -> update ((cidFromHead (I.targetHead A)), (I.Def c)) | _ -> () let rec remove (a, cid) = match Queue.deleteEnd (Array.sub (indexArray, a)) with | NONE -> () | SOME ((Const cid' as c), queue') -> if cid = cid' then Array.update (indexArray, a, queue') else () let rec uninstall cid = match I.sgnLookup cid with | ConDec (_, _, _, _, A, I.Type) -> remove ((cidFromHead (I.targetHead A)), cid) | ConDef (_, _, _, _, A, I.Type, _) -> remove ((cidFromHead (I.targetHead A)), cid) | _ -> () let rec resetFrom mark = let (limit, _) = I.sgnSize () in let iter i = if i < mark then () else (uninstall i; Array.update (indexArray, i, Queue.empty)) in iter (limit - 1) let rec lookup a = let lk arg0 = match arg0 with | (l, NONE) -> l | (l, SOME q') -> (Array.update (indexArray, a, q'); l) in lk (Queue.toList (Array.sub (indexArray, a))) let reset = reset let resetFrom = resetFrom let install = install let lookup = lookup;;