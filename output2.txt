module I = IntSyn let rec cidFromHead arg0 = match arg0 with | I.Const c -> c | I.Def c -> c let indexArray : (IntSyn.Head Queue.queue) Array.array = Array.array (Global.maxCid + 1, Queue.empty) let rec reset () = Array.modify (fun _ -> Queue.empty) indexArray let rec update (a, c) = Array.update (indexArray, a, Queue.insert (c, Array.sub (indexArray, a))) let rec install fromCS (H as I.Const c) = (match (fromCS, I.sgnLookup (c)) with (_, I.ConDec (_, _, _, _, A, I.Type)) => update (cidFromHead (I.targetHead A), H) | (I.Clause, I.ConDef (_, _, _, _, A, I.Type, _)) => (update (cidFromHead (I.targetHead A), I.Def(c))) | _ => ()) let rec remove (a, cid) = (match Queue.deleteEnd (Array.sub (indexArray, a)) with NONE -> () | SOME (c as I.Const cid', queue') -> if cid = cid' then Array.update (indexArray, a, queue') else ()) let rec uninstall cid = (match I.sgnLookup cid with I.ConDec (_, _, _, _, A, I.Type) -> remove (cidFromHead (I.targetHead A), cid) | I.ConDef (_, _, _, _, A, I.Type, _) -> remove (cidFromHead (I.targetHead A), cid) | _ -> ()) let rec resetFrom mark = let (limit, _) = I.sgnSize () in let rec iter i = if i < mark then () else (uninstall i; Array.update (indexArray, i, Queue.empty)) in in iter (limit - 1) let rec lookup a = let rec lk arg0 = match arg0 with | (l, NONE) -> l | (l, SOME(q')) -> (Array.update (indexArray, a, q'); l) in lk (Queue.toList (Array.sub (indexArray, a))) let reset = reset let resetFrom = resetFrom let install = install let lookup = lookup 